<?php
//!Related Exception Classes
class ELSWAK_Dictionary_Exception extends ELSWAK_Exception {}
class ELSWAK_Dictionary_InvalidKey_Exception extends ELSWAK_Dictionary_Exception {
	public function __construct($message = null, $code = 0, Exception $previous = null) {
		if (!$message) {
			$message = 'Unable to get value. Invalid key provided.';
		}
		return parent::__construct($message, $code, $previous);
	}
}

//!Stub Constants
if (!defined('JSON_PRETTY_PRINT')) {
	define('JSON_PRETTY_PRINT', 0);
}

// Place a stub for backward compatibility with PHP < 5.4.0
if (!interface_exists('JsonSerializable')) {
	require_once 'JsonSerializeableInterface.php';
}

/**
 * Wrap an associative array, throw in some methods, and call it a Dictionary.
 *
 * This class extends the Array Object class to ensure that added items
 * get a reasonable default name...
 *
 * @package ELSWAK\Collections
 */
class ELSWAK_Dictionary
	extends ELSWAK_Validated_Array {

//!Private Properties
	/**
	 * Prefix used for creating unique keys
	 * @var string
	 */
	private $_uniqueKeyPrefix;
	/**
	 * Suffix used for creating unique keys
	 * @var string
	 */
	private $_uniqueKeySuffix;

	/**
	 * Construct a new dictionary with optional import values.
	 * @param array|object $import collection to import
	 * @param string $prefix prefix for autogenerated keys
	 * @param string $suffix suffix for autogenerated keys
	 */
	public function __construct($import = null, $prefix = 'Item-', $suffix = '') {
		parent::__construct($import);
		$this->_uniqueKeyPrefix = $prefix;
		$this->_uniqueKeySuffix = $suffix;
	}



	/**
	 * Override the parent class
	 *
	 * When generating the next sequential key, utilize the unique key
	 * generator.
	 */
	public function nextSequentialKey() {
		return $this->uniqueKeyForValue(null);
	}

	/*
	 * Generate a unique key for the value.
	 *
	 * In this implementation it is superfluous to take the value as a parameter but subclasses may wish to overload this method with one which hashes or otherwise uses the value in key generation.
	 * @return string a unique key for the value
	 */
	public function uniqueKeyForValue($value = null) {
		$count = count($this->store) + 1;
		while (array_key_exists($this->_uniqueKeyPrefix.$count.$this->_uniqueKeySuffix, $this->store)) {
			++$count;
		}
		return $this->_uniqueKeyPrefix.$count.$this->_uniqueKeySuffix;
	}
}